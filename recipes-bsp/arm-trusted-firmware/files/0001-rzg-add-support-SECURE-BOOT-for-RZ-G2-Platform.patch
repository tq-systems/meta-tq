From 473940f794e7a6c951758ca69c99cee00ba0b8f6 Mon Sep 17 00:00:00 2001
From: hienhuynh <hien.huynh.px@renesas.com>
Date: Wed, 12 Aug 2020 15:20:12 +0700
Subject: [PATCH] rzg: add support SECURE BOOT for RZ/G2 Platform

This commit adds support SECURE BOOT for RZ/G2 Platform

Signed-off-by: hienhuynh <hien.huynh.px@renesas.com>
---
 drivers/renesas/rzg/auth/auth_mod.c           | 178 +++++++-----------
 drivers/renesas/rzg/io/io_rcar.c              | 146 +++------------
 plat/renesas/rzg/bl2_plat_mem_params_desc.c   |  31 ++++
 plat/renesas/rzg/bl2_plat_setup.c             |  30 ---
 plat/renesas/rzg/include/platform_def.h       |  13 ++
 plat/renesas/rzg/include/rcar_def.h           |   6 +
 plat/renesas/rzg/plat_storage.c               |  19 ++
 plat/renesas/rzg/platform.mk                  |   7 +-
 plat/renesas/rzg/sec_module/R_TSIP_Boot_Lib.h |  71 +++++++
 plat/renesas/rzg/sec_module/sec_module.c      | 256 ++++++++++++++++++++++++++
 plat/renesas/rzg/sec_module/sec_module.h      |  81 ++++++++
 plat/renesas/rzg/sec_module/sec_module.ld.S   |  53 ++++++
 plat/renesas/rzg/sec_module/sec_module.mk     |  80 ++++++++
 tools/renesas/rzg_layout_create/makefile      |   6 +
 tools/renesas/rzg_layout_create/sa6.c         |  41 +++++
 tools/renesas/rzg_layout_create/sa6.ld.S      |  26 +++
 16 files changed, 785 insertions(+), 259 deletions(-)
 create mode 100644 plat/renesas/rzg/sec_module/R_TSIP_Boot_Lib.h
 create mode 100644 plat/renesas/rzg/sec_module/sec_module.c
 create mode 100644 plat/renesas/rzg/sec_module/sec_module.h
 create mode 100644 plat/renesas/rzg/sec_module/sec_module.ld.S
 create mode 100644 plat/renesas/rzg/sec_module/sec_module.mk

diff --git a/drivers/renesas/rzg/auth/auth_mod.c b/drivers/renesas/rzg/auth/auth_mod.c
index 00701c8..491d730 100644
--- a/drivers/renesas/rzg/auth/auth_mod.c
+++ b/drivers/renesas/rzg/auth/auth_mod.c
@@ -14,24 +14,12 @@
 #include <lib/mmio.h>
 #include <plat/common/platform.h>
 
-#include "rom_api.h"
-
-typedef int32_t(*secure_boot_api_f) (uint32_t a, uint32_t b, void *c);
-extern int32_t rcar_get_certificate(const int32_t name, uint32_t *cert_addr);
-
-#define	RCAR_IMAGE_ID_MAX	(10)
-#define	RCAR_CERT_MAGIC_NUM	(0xE291F358U)
-#define RCAR_BOOT_KEY_CERT	(0xE6300C00U)
-#define RCAR_BOOT_KEY_CERT_NEW	(0xE6300F00U)
-#define	RST_BASE		(0xE6160000U)
-#define	RST_MODEMR		(RST_BASE + 0x0060U)
-#define	MFISOFTMDR		(0xE6260600U)
-#define	MODEMR_MD5_MASK		(0x00000020U)
-#define	MODEMR_MD5_SHIFT	(5U)
-#define	SOFTMD_BOOTMODE_MASK	(0x00000001U)
-#define	SOFTMD_NORMALBOOT	(0x1U)
+#if IMAGE_BL2 && RZG2_SECURE_BOOT
+#include "sec_module.h"
+#endif
 
-static secure_boot_api_f secure_boot_api;
+static st_sec_module_arg_t* secure_boot_arg;
+static fp_sec_module_api_t  secure_boot_api;
 
 int auth_mod_get_parent_id(unsigned int img_id, unsigned int *parent_id)
 {
@@ -40,52 +28,11 @@ int auth_mod_get_parent_id(unsigned int img_id, unsigned int *parent_id)
 
 int auth_mod_verify_img(unsigned int img_id, void *ptr, unsigned int len)
 {
-	int32_t ret = 0, index = 0;
-	uint32_t cert_addr = 0U;
-	static const struct img_to_cert_t {
-		uint32_t id;
-		int32_t cert;
-		const char *name;
-	} image[RCAR_IMAGE_ID_MAX] = {
-		{ BL31_IMAGE_ID, SOC_FW_CONTENT_CERT_ID, "BL31" },
-		{ BL32_IMAGE_ID, TRUSTED_OS_FW_CONTENT_CERT_ID, "BL32" },
-		{ BL33_IMAGE_ID, NON_TRUSTED_FW_CONTENT_CERT_ID, "BL33" },
-		{ BL332_IMAGE_ID, BL332_CERT_ID, "BL332" },
-		{ BL333_IMAGE_ID, BL333_CERT_ID, "BL333" },
-		{ BL334_IMAGE_ID, BL334_CERT_ID, "BL334" },
-		{ BL335_IMAGE_ID, BL335_CERT_ID, "BL335" },
-		{ BL336_IMAGE_ID, BL336_CERT_ID, "BL336" },
-		{ BL337_IMAGE_ID, BL337_CERT_ID, "BL337" },
-		{ BL338_IMAGE_ID, BL338_CERT_ID, "BL338" },
-	};
-
-#if IMAGE_BL2
+	int32_t ret = 0;
+
+#if IMAGE_BL2 && RZG2_SECURE_BOOT
+
 	switch (img_id) {
-	case TRUSTED_KEY_CERT_ID:
-	case SOC_FW_KEY_CERT_ID:
-	case TRUSTED_OS_FW_KEY_CERT_ID:
-	case NON_TRUSTED_FW_KEY_CERT_ID:
-	case BL332_KEY_CERT_ID:
-	case BL333_KEY_CERT_ID:
-	case BL334_KEY_CERT_ID:
-	case BL335_KEY_CERT_ID:
-	case BL336_KEY_CERT_ID:
-	case BL337_KEY_CERT_ID:
-	case BL338_KEY_CERT_ID:
-	case SOC_FW_CONTENT_CERT_ID:
-	case TRUSTED_OS_FW_CONTENT_CERT_ID:
-	case NON_TRUSTED_FW_CONTENT_CERT_ID:
-	case BL332_CERT_ID:
-	case BL333_CERT_ID:
-	case BL334_CERT_ID:
-	case BL335_CERT_ID:
-	case BL336_CERT_ID:
-	case BL337_CERT_ID:
-	case BL338_CERT_ID:
-		return ret;
-	case BL31_IMAGE_ID:
-	case BL32_IMAGE_ID:
-	case BL33_IMAGE_ID:
 	case BL332_IMAGE_ID:
 	case BL333_IMAGE_ID:
 	case BL334_IMAGE_ID:
@@ -93,34 +40,67 @@ int auth_mod_verify_img(unsigned int img_id, void *ptr, unsigned int len)
 	case BL336_IMAGE_ID:
 	case BL337_IMAGE_ID:
 	case BL338_IMAGE_ID:
-		goto verify_image;
-	default:
-		return -1;
-	}
+		return ret;
 
-verify_image:
-	for (index = 0; index < RCAR_IMAGE_ID_MAX; index++) {
-		if (img_id != image[index].id)
-			continue;
+	case SEC_MODULE_ID:
+	
+		/* Load Security Module to authenticate the program. */
+		secure_boot_arg = (st_sec_module_arg_t *) ptr;
+		secure_boot_api = (fp_sec_module_api_t)((uint64_t)ptr + SEC_MODULE_SHARED_SIZE);
+		return ret;
+		
+	case SEC_KEYRING_ID:
+
+		/* Load the key ring and initialize Security Module. */
+		if (NULL == secure_boot_arg) {
+			
+			return -1;
+		}
+		
+		secure_boot_arg->cmd = CMD_RESET_INIT;
+		secure_boot_arg->len = sizeof(st_reset_init_t);
+		(secure_boot_arg->prm).reset_init.inst_area = (uint64_t) ptr;
+		break;
+		
+	case BL31_IMAGE_ID:
+	case BL32_IMAGE_ID:
+	case BL33_IMAGE_ID:
 
-		ret = rcar_get_certificate(image[index].cert, &cert_addr);
+		/* Authenticate the loaded program with Security Module. */
+		if (NULL == secure_boot_arg) {
+			
+			return -1;
+		}
+		
+		/* The arguments of Security Module are placed in the header of the program to be authenticated. */
+		*secure_boot_arg = *(st_sec_module_arg_t *) ptr;
+
+		if (CMD_VERIFY_DATA == secure_boot_arg->cmd) {
+			
+			(secure_boot_arg->prm).verify_data.heap = (uint64_t) SEC_MODULE_HEAP;
+		}
 		break;
+		
+	default:
+		return -1;
 	}
 
-	if (ret || (index == RCAR_IMAGE_ID_MAX)) {
-		ERROR("Verification Failed for image id = %d\n", img_id);
-		return ret;
-	}
 #if RCAR_BL2_DCACHE == 1
 	/* clean and disable */
 	write_sctlr_el3(read_sctlr_el3() & ~SCTLR_C_BIT);
 	dcsw_op_all(DCCISW);
 #endif
-	ret = (mmio_read_32(RCAR_BOOT_KEY_CERT_NEW) == RCAR_CERT_MAGIC_NUM) ?
-	    secure_boot_api(RCAR_BOOT_KEY_CERT_NEW, cert_addr, NULL) :
-	    secure_boot_api(RCAR_BOOT_KEY_CERT, cert_addr, NULL);
-	if (ret)
-		ERROR("Verification Failed 0x%x, %s\n", ret, image[index].name);
+
+	/* Call Security Module */
+	if(SEC_MODULE_RET_OK != secure_boot_api())
+	{
+		ERROR("Verification Failed for image id = %d\n", img_id);
+		ret = -1;
+	}
+	else
+	{
+		NOTICE("Verification Successful for image id = %d\n", img_id);
+	}
 
 #if RCAR_BL2_DCACHE == 1
 	/* enable */
@@ -131,43 +111,23 @@ verify_image:
 	return ret;
 }
 
-static int32_t normal_boot_verify(uint32_t a, uint32_t b, void *c)
+static int32_t normal_boot_verify(void)
 {
+#if RZG2_SECURE_BOOT
+	return -1;
+#else
 	return 0;
+#endif
 }
 
 void auth_mod_init(void)
 {
 #if RZG2_SECURE_BOOT
-	uint32_t soft_md = mmio_read_32(MFISOFTMDR) & SOFTMD_BOOTMODE_MASK;
-	uint32_t md = mmio_read_32(RST_MODEMR) & MODEMR_MD5_MASK;
-	uint32_t lcs, ret;
-
-	secure_boot_api = (secure_boot_api_f) &rcar_rom_secure_boot_api;
-
-	ret = rcar_rom_get_lcs(&lcs);
-	if (ret) {
-		ERROR("BL2: Failed to get the LCS. (%d)\n", ret);
-		panic();
-	}
-
-	switch (lcs) {
-	case LCS_SE:
-		if (soft_md == SOFTMD_NORMALBOOT)
-			secure_boot_api = &normal_boot_verify;
-		break;
-	case LCS_SD:
-		secure_boot_api = &normal_boot_verify;
-		break;
-	default:
-		if (md >> MODEMR_MD5_SHIFT)
-			secure_boot_api = &normal_boot_verify;
-	}
-
-	NOTICE("BL2: %s boot\n",
-	       secure_boot_api == &normal_boot_verify ? "Normal" : "Secure");
+	NOTICE("BL2: Secure boot\n");
+	secure_boot_api = (fp_sec_module_api_t) &normal_boot_verify;
 #else
 	NOTICE("BL2: Normal boot\n");
-	secure_boot_api = &normal_boot_verify;
+	secure_boot_api = (fp_sec_module_api_t) &normal_boot_verify;
 #endif
+	secure_boot_arg = NULL;
 }
diff --git a/drivers/renesas/rzg/io/io_rcar.c b/drivers/renesas/rzg/io/io_rcar.c
index b82c510..ae4bdfa 100644
--- a/drivers/renesas/rzg/io/io_rcar.c
+++ b/drivers/renesas/rzg/io/io_rcar.c
@@ -72,58 +72,42 @@ typedef struct {
 #define RCAR_CERT_SIZE			(0x800U)
 #define RCAR_CERT_INFO_SIZE_OFFSET	(0x264U)
 #define RCAR_CERT_INFO_DST_OFFSET	(0x154U)
-#define RCAR_CERT_INFO_SIZE_OFFSET1	(0x364U)
-#define RCAR_CERT_INFO_DST_OFFSET1	(0x1D4U)
-#define RCAR_CERT_INFO_SIZE_OFFSET2	(0x464U)
-#define RCAR_CERT_INFO_DST_OFFSET2	(0x254U)
 #define RCAR_CERT_LOAD			(1U)
 
 #define RCAR_FLASH_CERT_HEADER		RCAR_GET_FLASH_ADR(6U, 0U)
 #define RCAR_EMMC_CERT_HEADER		(0x00030000U)
 
-#define RCAR_COUNT_LOAD_BL33		(2U)
-#define RCAR_COUNT_LOAD_BL33X		(3U)
+#define RCAR_COUNT_LOAD_BL31		(2U)
+#define RCAR_COUNT_LOAD_BL33		(4U)
+
+#define RCAR_MAX_LOAD_IMAGE		(RCAR_MAX_BL3X_IMAGE + RCAR_COUNT_LOAD_BL33)
 
 static const plat_rcar_name_offset_t name_offset[] = {
-	{BL31_IMAGE_ID, 0U, RCAR_ATTR_SET_ALL(0, 0, 0)},
 
-	/* BL3-2 is optional in the platform */
-	{BL32_IMAGE_ID, 0U, RCAR_ATTR_SET_ALL(1, 0, 1)},
-	{BL33_IMAGE_ID, 0U, RCAR_ATTR_SET_ALL(2, 0, 2)},
-	{BL332_IMAGE_ID, 0U, RCAR_ATTR_SET_ALL(3, 0, 3)},
-	{BL333_IMAGE_ID, 0U, RCAR_ATTR_SET_ALL(4, 0, 4)},
-	{BL334_IMAGE_ID, 0U, RCAR_ATTR_SET_ALL(5, 0, 5)},
-	{BL335_IMAGE_ID, 0U, RCAR_ATTR_SET_ALL(6, 0, 6)},
-	{BL336_IMAGE_ID, 0U, RCAR_ATTR_SET_ALL(7, 0, 7)},
-	{BL337_IMAGE_ID, 0U, RCAR_ATTR_SET_ALL(8, 0, 8)},
-	{BL338_IMAGE_ID, 0U, RCAR_ATTR_SET_ALL(9, 0, 9)},
-};
+	{SEC_MODULE_ID,  0U, RCAR_ATTR_SET_ALL(0, 0, 0)},
+	{SEC_KEYRING_ID, 0U, RCAR_ATTR_SET_ALL(1, 0, 1)},
 
-#if TRUSTED_BOARD_BOOT
-static const plat_rcar_name_offset_t cert_offset[] = {
-	/* Certificates */
-	{TRUSTED_KEY_CERT_ID, 0U, RCAR_ATTR_SET_ALL(0, 1, 0)},
-	{SOC_FW_KEY_CERT_ID, 0U, RCAR_ATTR_SET_ALL(0, 1, 0)},
-	{TRUSTED_OS_FW_KEY_CERT_ID, 0U, RCAR_ATTR_SET_ALL(0, 1, 0)},
-	{NON_TRUSTED_FW_KEY_CERT_ID, 0U, RCAR_ATTR_SET_ALL(0, 1, 0)},
-	{SOC_FW_CONTENT_CERT_ID, 0U, RCAR_ATTR_SET_ALL(0, 1, 0)},
-	{TRUSTED_OS_FW_CONTENT_CERT_ID, 0U, RCAR_ATTR_SET_ALL(0, 1, 1)},
-	{NON_TRUSTED_FW_CONTENT_CERT_ID, 0U, RCAR_ATTR_SET_ALL(0, 1, 2)},
-	{BL332_CERT_ID, 0U, RCAR_ATTR_SET_ALL(0, 1, 3)},
-	{BL333_CERT_ID, 0U, RCAR_ATTR_SET_ALL(0, 1, 4)},
-	{BL334_CERT_ID, 0U, RCAR_ATTR_SET_ALL(0, 1, 5)},
-	{BL335_CERT_ID, 0U, RCAR_ATTR_SET_ALL(0, 1, 6)},
-	{BL336_CERT_ID, 0U, RCAR_ATTR_SET_ALL(0, 1, 7)},
-	{BL337_CERT_ID, 0U, RCAR_ATTR_SET_ALL(0, 1, 8)},
-	{BL338_CERT_ID, 0U, RCAR_ATTR_SET_ALL(0, 1, 9)},
+	{BL31_IMAGE_ID, 0U, RCAR_ATTR_SET_ALL(RCAR_COUNT_LOAD_BL31,    0, RCAR_COUNT_LOAD_BL31)  },
+
+	/* BL3-2 is optional in the platform */
+	{BL32_IMAGE_ID,  0U, RCAR_ATTR_SET_ALL(RCAR_COUNT_LOAD_BL31+1, 0, RCAR_COUNT_LOAD_BL31+1)},
+
+	/* BL33 is non trusted firmwarel in the platform */
+	{BL33_IMAGE_ID,  0U, RCAR_ATTR_SET_ALL(RCAR_COUNT_LOAD_BL33,   0, RCAR_COUNT_LOAD_BL33)  },
+	{BL332_IMAGE_ID, 0U, RCAR_ATTR_SET_ALL(RCAR_COUNT_LOAD_BL33+1, 0, RCAR_COUNT_LOAD_BL33+1)},
+	{BL333_IMAGE_ID, 0U, RCAR_ATTR_SET_ALL(RCAR_COUNT_LOAD_BL33+2, 0, RCAR_COUNT_LOAD_BL33+2)},
+	{BL334_IMAGE_ID, 0U, RCAR_ATTR_SET_ALL(RCAR_COUNT_LOAD_BL33+3, 0, RCAR_COUNT_LOAD_BL33+3)},
+	{BL335_IMAGE_ID, 0U, RCAR_ATTR_SET_ALL(RCAR_COUNT_LOAD_BL33+4, 0, RCAR_COUNT_LOAD_BL33+4)},
+	{BL336_IMAGE_ID, 0U, RCAR_ATTR_SET_ALL(RCAR_COUNT_LOAD_BL33+5, 0, RCAR_COUNT_LOAD_BL33+5)},
+	{BL337_IMAGE_ID, 0U, RCAR_ATTR_SET_ALL(RCAR_COUNT_LOAD_BL33+6, 0, RCAR_COUNT_LOAD_BL33+6)},
+	{BL338_IMAGE_ID, 0U, RCAR_ATTR_SET_ALL(RCAR_COUNT_LOAD_BL33+7, 0, RCAR_COUNT_LOAD_BL33+7)},
 };
-#endif /* TRUSTED_BOARD_BOOT */
 
 static file_state_t current_file = { 0 };
 
 static uintptr_t rcar_handle, rcar_spec;
-static uint64_t rcar_image_header[RCAR_MAX_BL3X_IMAGE + 2U] = { 0U };
-static uint64_t rcar_image_header_prttn[RCAR_MAX_BL3X_IMAGE + 2U] = { 0U };
+static uint64_t rcar_image_header[RCAR_MAX_LOAD_IMAGE] = { 0U };
+static uint64_t rcar_image_header_prttn[RCAR_MAX_LOAD_IMAGE] = { 0U };
 static uint64_t rcar_image_number = { 0U };
 static uint32_t rcar_cert_load = { 0U };
 
@@ -132,23 +116,6 @@ static io_type_t device_type_rcar(void)
 	return IO_TYPE_FIRMWARE_IMAGE_PACKAGE;
 }
 
-int32_t rcar_get_certificate(const int32_t name, uint32_t *cert)
-{
-#if TRUSTED_BOARD_BOOT
-	int32_t i;
-	for (i = 0; i < ARRAY_SIZE(cert_offset); i++) {
-		if (name != cert_offset[i].name)
-			continue;
-
-		*cert = RCAR_CERT_SIZE;
-		*cert *= RCAR_ATTR_GET_CERTOFF(cert_offset[i].attr);
-		*cert += RCAR_SDRAM_certESS;
-		return 0;
-	}
-#endif
-	return -EINVAL;
-}
-
 static int32_t file_to_offset(const int32_t name, uintptr_t *offset,
 			      uint32_t *cert, uint32_t *no_load,
 			      uintptr_t *partition)
@@ -161,7 +128,7 @@ static int32_t file_to_offset(const int32_t name, uintptr_t *offset,
 			continue;
 
 		addr = RCAR_ATTR_GET_CALCADDR(name_offset[i].attr);
-		if (rcar_image_number + 2 < addr)
+		if ((rcar_image_number + RCAR_COUNT_LOAD_BL33) < addr)
 			continue;
 
 		*offset = rcar_image_header[addr];
@@ -173,74 +140,15 @@ static int32_t file_to_offset(const int32_t name, uintptr_t *offset,
 		return IO_SUCCESS;
 	}
 
-#if TRUSTED_BOARD_BOOT
-	for (i = 0; i < ARRAY_SIZE(cert_offset); i++) {
-		if (name != cert_offset[i].name)
-			continue;
-
-		*no_load = RCAR_ATTR_GET_ISNOLOAD(cert_offset[i].attr);
-		*partition = 0U;
-		*offset = 0U;
-		*cert = 0U;
-		return IO_SUCCESS;
-	}
-#endif
 	return -EINVAL;
 }
 
-#define RCAR_BOOT_KEY_CERT_NEW	(0xE6300F00U)
-#define	RCAR_CERT_MAGIC_NUM	(0xE291F358U)
-
 void rcar_read_certificate(uint64_t cert, uint32_t *len, uintptr_t *dst)
 {
-	uint32_t seed, val, info_1, info_2;
 	uintptr_t size, dsth, dstl;
 
 	cert &= 0xFFFFFFFFU;
 
-	seed = mmio_read_32(RCAR_BOOT_KEY_CERT_NEW);
-	val = mmio_read_32(RCAR_BOOT_KEY_CERT_NEW + 0xC);
-	info_1 = (val >> 18) & 0x3U;
-	val = mmio_read_32(cert + 0xC);
-	info_2 = (val >> 21) & 0x3;
-
-	if (seed == RCAR_CERT_MAGIC_NUM) {
-		if (info_1 != 1) {
-			ERROR("BL2: Cert is invalid.\n");
-			*dst = 0;
-			*len = 0;
-			return;
-		}
-
-		if (info_2 > 2) {
-			ERROR("BL2: Cert is invalid.\n");
-			*dst = 0;
-			*len = 0;
-			return;
-		}
-
-		switch (info_2) {
-		case 2:
-			size = cert + RCAR_CERT_INFO_SIZE_OFFSET2;
-			dstl = cert + RCAR_CERT_INFO_DST_OFFSET2;
-			break;
-		case 1:
-			size = cert + RCAR_CERT_INFO_SIZE_OFFSET1;
-			dstl = cert + RCAR_CERT_INFO_DST_OFFSET1;
-			break;
-		case 0:
-			size = cert + RCAR_CERT_INFO_SIZE_OFFSET;
-			dstl = cert + RCAR_CERT_INFO_DST_OFFSET;
-			break;
-		}
-
-		*len = mmio_read_32(size) * 4U;
-		dsth = dstl + 4U;
-		*dst = ((uintptr_t) mmio_read_32(dsth) << 32) +
-		    ((uintptr_t) mmio_read_32(dstl));
-		return;
-	}
-
 	size = cert + RCAR_CERT_INFO_SIZE_OFFSET;
 	*len = mmio_read_32(size) * 4U;
 	dstl = cert + RCAR_CERT_INFO_DST_OFFSET;
@@ -418,7 +326,7 @@ static int32_t rcar_dev_init(io_dev_info_t *dev_info, const uintptr_t name)
 	}
 
 	rcar_image_number = header[0];
-	for (i = 0; i < rcar_image_number + 2; i++) {
+	for (i = 0; i < rcar_image_number + RCAR_COUNT_LOAD_BL33; i++) {
 		rcar_image_header[i] = header[i * 2 + 1];
 		rcar_image_header_prttn[i] = header[i * 2 + 2];
 	}
@@ -435,10 +343,10 @@ static int32_t rcar_dev_init(io_dev_info_t *dev_info, const uintptr_t name)
 	}
 #if RCAR_BL2_DCACHE == 1
 	inv_dcache_range(RCAR_SDRAM_certESS,
-			 RCAR_CERT_SIZE * (2 + rcar_image_number));
+			 RCAR_CERT_SIZE * (RCAR_COUNT_LOAD_BL33 + rcar_image_number));
 #endif
 	rc = io_read(handle, RCAR_SDRAM_certESS,
-		     RCAR_CERT_SIZE * (2 + rcar_image_number), &cnt);
+		     RCAR_CERT_SIZE * (RCAR_COUNT_LOAD_BL33 + rcar_image_number), &cnt);
 	if (rc != IO_SUCCESS) {
 		WARN("cert file read error.\n");
 		goto error;
@@ -573,7 +481,7 @@ static int32_t rcar_file_read(io_entity_t *entity, uintptr_t buffer,
 	io_close(handle);
 
 	load_bl33x_counter += 1;
-	if (load_bl33x_counter == RCAR_COUNT_LOAD_BL33X)
+	if (load_bl33x_counter == (RCAR_COUNT_LOAD_BL33 + 1))
 		return load_bl33x();
 
 	return IO_SUCCESS;
diff --git a/plat/renesas/rzg/bl2_plat_mem_params_desc.c b/plat/renesas/rzg/bl2_plat_mem_params_desc.c
index 3b124c7..bf23ba6 100644
--- a/plat/renesas/rzg/bl2_plat_mem_params_desc.c
+++ b/plat/renesas/rzg/bl2_plat_mem_params_desc.c
@@ -24,6 +24,37 @@
 extern uint64_t fdt_blob[PAGE_SIZE_4KB / sizeof(uint64_t)];
 
 static bl_mem_params_node_t bl2_mem_params_descs[] = {
+#if RZG2_SECURE_BOOT
+	{
+		.image_id = SEC_MODULE_ID,
+
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP, VERSION_2,
+		entry_point_info_t, SECURE | NON_EXECUTABLE),
+
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_IMAGE_BINARY, VERSION_2,
+		image_info_t, 0),
+
+		.image_info.image_base = SEC_MODULE_BASE,
+		.image_info.image_max_size = SEC_MODULE_LIMIT - SEC_MODULE_BASE,
+
+		.next_handoff_image_id = INVALID_IMAGE_ID,
+	},
+	{
+		.image_id = SEC_KEYRING_ID,
+
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP, VERSION_2,
+		entry_point_info_t, SECURE | NON_EXECUTABLE),
+
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_IMAGE_BINARY, VERSION_2,
+		image_info_t, 0),
+
+		.image_info.image_base = SEC_KEYRING_BASE,
+		.image_info.image_max_size = SEC_KEYRING_LIMIT - SEC_KEYRING_BASE,
+
+		.next_handoff_image_id = INVALID_IMAGE_ID,
+	},
+#endif
+
 	{
 		.image_id = BL31_IMAGE_ID,
 
diff --git a/plat/renesas/rzg/bl2_plat_setup.c b/plat/renesas/rzg/bl2_plat_setup.c
index 441fedf..4fceb93 100644
--- a/plat/renesas/rzg/bl2_plat_setup.c
+++ b/plat/renesas/rzg/bl2_plat_setup.c
@@ -33,7 +33,6 @@
 #endif
 
 #include "io_common.h"
-#include "io_rcar.h"
 #include "qos_init.h"
 #include "rcar_def.h"
 #include "rcar_private.h"
@@ -369,28 +368,10 @@ cold_boot:
 	return 0;
 }
 
-static uint64_t rcar_get_dest_addr_from_cert(uint32_t certid, uintptr_t *dest)
-{
-	uint32_t cert, len;
-	int ret;
-
-	ret = rcar_get_certificate(certid, &cert);
-	if (ret) {
-		ERROR("%s : cert file load error", __func__);
-		return 1;
-	}
-
-	rcar_read_certificate((uint64_t) cert, &len, dest);
-
-	return 0;
-}
-
 int bl2_plat_handle_post_image_load(unsigned int image_id)
 {
 	static bl2_to_bl31_params_mem_t *params;
 	bl_mem_params_node_t *bl_mem_params;
-	uintptr_t dest;
-	int ret;
 
 	if (!params) {
 		params = (bl2_to_bl31_params_mem_t *) PARAMS_BASE;
@@ -401,19 +382,8 @@ int bl2_plat_handle_post_image_load(unsigned int image_id)
 
 	switch (image_id) {
 	case BL31_IMAGE_ID:
-		ret = rcar_get_dest_addr_from_cert(SOC_FW_CONTENT_CERT_ID,
-						   &dest);
-		if (!ret)
-			bl_mem_params->image_info.image_base = dest;
 		break;
 	case BL32_IMAGE_ID:
-		ret = rcar_get_dest_addr_from_cert(TRUSTED_OS_FW_CONTENT_CERT_ID,
-						   &dest);
-		if (!ret)
-			bl_mem_params->image_info.image_base = dest;
-
-		memcpy(&params->bl32_ep_info, &bl_mem_params->ep_info,
-			sizeof(entry_point_info_t));
 		break;
 	case BL33_IMAGE_ID:
 		memcpy(&params->bl33_ep_info, &bl_mem_params->ep_info,
diff --git a/plat/renesas/rzg/include/platform_def.h b/plat/renesas/rzg/include/platform_def.h
index bb0c7d3..f330651 100644
--- a/plat/renesas/rzg/include/platform_def.h
+++ b/plat/renesas/rzg/include/platform_def.h
@@ -69,6 +69,9 @@
 #define BL337_CERT_ID		(NS_BL2U_IMAGE_ID + 20)
 #define BL338_CERT_ID		(NS_BL2U_IMAGE_ID + 21)
 
+#define SEC_MODULE_ID		(NS_BL2U_IMAGE_ID + 22)
+#define SEC_KEYRING_ID		(NS_BL2U_IMAGE_ID + 23)
+
 /* io drivers id */
 #define FLASH_DEV_ID		U(0)
 #define EMMC_DEV_ID		U(1)
@@ -148,6 +151,16 @@
  ******************************************************************************/
 #define BL33_BASE		DRAM1_NS_BASE
 
+/*******************************************************************************
+ * Security Module for Authentication
+ ******************************************************************************/
+#define SEC_MODULE_BASE		(RZG2_AUTH_MOD_BASE)
+#define SEC_MODULE_LIMIT	(SEC_MODULE_BASE + 0x1E000)
+
+#define SEC_KEYRING_BASE	(SEC_MODULE_LIMIT)
+#define SEC_KEYRING_LIMIT	(RZG2_AUTH_MOD_BASE + RZG2_AUTH_MOD_SIZE)
+
+#define SEC_MODULE_HEAP		U(0x50100000)
 
 /*******************************************************************************
  * Platform specific page table and MMU setup constants
diff --git a/plat/renesas/rzg/include/rcar_def.h b/plat/renesas/rzg/include/rcar_def.h
index 0ffbfe9..4dfc56c 100644
--- a/plat/renesas/rzg/include/rcar_def.h
+++ b/plat/renesas/rzg/include/rcar_def.h
@@ -40,6 +40,12 @@
 #define	DRAM_PROTECTED_SIZE		ULL(0x03F00000)
 #define	RCAR_BL31_CRASH_BASE		U(0x4403F000)
 #define	RCAR_BL31_CRASH_SIZE		U(0x00001000)
+#ifndef SPD_NONE
+#define RZG2_AUTH_MOD_BASE		U(0x440E0000) /* secure */
+#else
+#define RZG2_AUTH_MOD_BASE		U(0x4A000000) /* non secure */
+#endif
+#define RZG2_AUTH_MOD_SIZE		U(0x00020000)
 /* Entrypoint mailboxes */
 #define MBOX_BASE			RCAR_SHARED_MEM_BASE
 #define MBOX_SIZE			0x200
diff --git a/plat/renesas/rzg/plat_storage.c b/plat/renesas/rzg/plat_storage.c
index a6db4e6..0b1c9e3 100644
--- a/plat/renesas/rzg/plat_storage.c
+++ b/plat/renesas/rzg/plat_storage.c
@@ -74,6 +74,15 @@ static const io_block_spec_t bl338_file_spec = {
 	.offset = BL338_IMAGE_ID,
 };
 
+#if RZG2_SECURE_BOOT
+static const io_block_spec_t secmod_file_spec = {
+	.offset = SEC_MODULE_ID,
+};
+
+static const io_block_spec_t seckey_file_spec = {
+	.offset = SEC_KEYRING_ID,
+};
+#endif
 
 static int32_t open_emmcdrv(const uintptr_t spec);
 static int32_t open_memmap(const uintptr_t spec);
@@ -134,6 +143,16 @@ static const struct plat_io_policy policies[] = {
 			    &rcar_dev_handle,
 			    (uintptr_t) &bl338_file_spec,
 			    &open_rcar},
+#if RZG2_SECURE_BOOT
+	[SEC_MODULE_ID] = {
+			    &rcar_dev_handle,
+			    (uintptr_t) &secmod_file_spec,
+			    &open_rcar},
+	[SEC_KEYRING_ID] = {
+			    &rcar_dev_handle,
+			    (uintptr_t) &seckey_file_spec,
+			    &open_rcar},
+#endif
 			{
 			    0, 0, 0
 			}
diff --git a/plat/renesas/rzg/platform.mk b/plat/renesas/rzg/platform.mk
index d48fadd..aca09f5 100644
--- a/plat/renesas/rzg/platform.mk
+++ b/plat/renesas/rzg/platform.mk
@@ -351,6 +351,7 @@ PLAT_INCLUDES	:=	-Idrivers/renesas/rzg/ddr		\
 			-Idrivers/renesas/rcar/pwrc		\
 			-Idrivers/renesas/rzg/io		\
 			-Iplat/renesas/rzg/include		\
+			-Iplat/renesas/rzg/sec_module		\
 			-Iplat/renesas/rcar/include/registers	\
 			-Iplat/renesas/rcar/include		\
 			-Iplat/renesas/rcar
@@ -439,7 +440,7 @@ clean_layout_tool:
 .PHONY: rzg_layout_create
 rzg_layout_create:
 	@echo "generating layout srecs"
-	${Q}${MAKE} CPPFLAGS="-D=AARCH64" ARCH=$(ARCH) --no-print-directory -C ${LAYOUT_TOOLPATH}
+	${Q}${MAKE} CPPFLAGS="-D=AARCH64" ARCH=$(ARCH)  SPD_NONE=$(SPD_NONE) --no-print-directory -C ${LAYOUT_TOOLPATH}
 
 # srecords
 SREC_PATH	= ${BUILD_PLAT}
@@ -457,3 +458,7 @@ rzg_srecord: $(BL2_ELF_SRC) $(BL31_ELF_SRC)
 	@echo "generating srec: ${SREC_PATH}/bl31.srec"
 	$(Q)$(OC) -O srec --srec-forceS3 ${BL31_ELF_SRC} ${SREC_PATH}/bl31.srec
 
+# Security Module
+.PHONY: sec_module
+sec_module:
+include plat/renesas/rzg/sec_module/sec_module.mk
diff --git a/plat/renesas/rzg/sec_module/R_TSIP_Boot_Lib.h b/plat/renesas/rzg/sec_module/R_TSIP_Boot_Lib.h
new file mode 100644
index 0000000..9d6c57e
--- /dev/null
+++ b/plat/renesas/rzg/sec_module/R_TSIP_Boot_Lib.h
@@ -0,0 +1,71 @@
+/***********************************************************************************************************************
+* DISCLAIMER
+* This software is supplied by Renesas Electronics Corporation and is only intended for use with Renesas products. No 
+* other uses are authorized. This software is owned by Renesas Electronics Corporation and is protected under all 
+* applicable laws, including copyright laws. 
+* THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
+* THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, 
+* FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED. TO THE MAXIMUM 
+* EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES 
+* SHALL BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR ANY REASON RELATED TO THIS 
+* SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+* Renesas reserves the right, without notice, to make changes to this software and to discontinue the availability of 
+* this software. By using this software, you agree to the additional terms and conditions found by accessing the 
+* following link:
+* http://www.renesas.com/disclaimer 
+*
+* Copyright (C) 2011 - 2019 Renesas Electronics Corporation. All rights reserved.    
+***********************************************************************************************************************/
+
+/*! *****************************************************************************
+    @file    R_TSIP_BOOT_LIB.h
+    @brief   TSIP Security Driver Boot Library API(No OS)
+    
+    @par    Copyright
+    Renesas Electronics Corporation. All rights reserved.
+    @par    History
+    -    2019-02-18 : 2.2.01 keyring verification for RZ/G2
+    -    2019-10-28 : 2.2.02 user data verification for RZ/G2
+ ********************************************************************************/
+
+#ifndef  R_TSIP_BOOT_LIB_H_
+#define  R_TSIP_BOOT_LIB_H_
+
+/* Define */
+#define R_PASS                       (0x00000000)
+#define R_INITIALIZATION_FAIL        (0x00000001)
+#define R_PARAMETER_FAIL             (0x00000002)
+#define R_SEQUENCE_FAIL              (0x00000003)
+#define R_RESOURCE_CONFLICT_FAIL     (0x00000004)
+#define R_VERIFICATION_FAIL          (0x00000005)
+#define R_SERVERMESSAGE_FAIL         (0x00000006)
+#define R_SERVER_VERIFICATION_FAIL   (0x00000007)
+#define R_ROOTCA_CERTIFICATION_FAIL  (0x00000008)
+#define R_USEKEY_FAIL                (0x00000009)
+#define R_CONNECTSESSION_FAIL        (0x0000000A)
+#define R_INDATA_OUTDATA_ACCESS_FAIL (0x0000000B)
+#define R_PROVISIONING_KEY_FAIL      (0x0000000C)
+#define R_GENERATION_FAIL            (0x0000000D)
+#define R_KEYRING_FORMAT_FAIL        (0x0000000E)
+#define R_ALLOCATE_MEMORY_FAIL       (0x00000020)
+#define R_MMAP_FAIL                  (0x00000021)
+#define R_INITIALIZATION_ERROR       (0x00000080)
+
+#define REENC_BOOT_DATA_MAX             (16)
+
+typedef struct str_tsip_reenc_boot_data {
+	unsigned char *InData_BootData;
+	unsigned long  InData_BootData_ByteSize;
+	unsigned char *OutData_BootData;
+} TSIP_REENC_BOOT_DATA[REENC_BOOT_DATA_MAX];
+
+
+/* API */
+unsigned long R_TSIP_Init(unsigned char *S_RAMData, unsigned char *S_INSTData);
+unsigned long R_TSIP_Inject_Key(unsigned char *InData_ProvisioningKeyOperationCode, unsigned char *InData_KeyRingOperationCode);
+unsigned long R_TSIP_ReEncBootData(TSIP_REENC_BOOT_DATA  *tsip_reenc_bootdata);
+unsigned long R_TSIP_Inject_Addon_Key(unsigned long InData_Operation, unsigned char *InData_IV, unsigned char *InData_KeyOperationCode, unsigned char *OutData_KeyOperationCode);
+unsigned long R_TSIP_VerifyBootData(unsigned char *InData_BootData, unsigned long InData_BootData_ByteSize, unsigned char *InData_BootData_HeapArea, unsigned char *OutData_BootData);
+unsigned long R_TSIP_KeyRing_Verify(void);
+
+#endif  /* R_TSIP_BOOT_LIB_H_ */
diff --git a/plat/renesas/rzg/sec_module/sec_module.c b/plat/renesas/rzg/sec_module/sec_module.c
new file mode 100644
index 0000000..8851d1a
--- /dev/null
+++ b/plat/renesas/rzg/sec_module/sec_module.c
@@ -0,0 +1,256 @@
+/*
+ * Copyright (c) 2020, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/******************************************************************************
+ Includes <System Includes> , "Project Includes"
+******************************************************************************/
+#include <stdint.h>
+#include <string.h>
+
+#include <platform_def.h>
+
+#include "sec_module.h"
+#include "R_TSIP_Boot_Lib.h"
+
+/******************************************************************************
+Macro definitions
+******************************************************************************/
+
+#define WORK_ADR_SRAM_SIZE (432)
+
+/******************************************************************************
+Typedef definitions
+******************************************************************************/
+typedef int (* func_cmd) (unsigned int len, void* const param);
+
+/******************************************************************************
+Exported global variables and functions (to be accessed by other files)
+******************************************************************************/
+volatile st_sec_module_arg_t gs_arguments __attribute__((section("SHARED_AREA"))) = {0};
+
+/******************************************************************************
+Private global variables and functions
+******************************************************************************/
+static int cmd_reset_init(unsigned int len, void * const param);
+static int cmd_inject_key(unsigned int len, void * const param);
+static int cmd_re_enc_data(unsigned int len, void * const param);
+static int cmd_verify_key(unsigned int len, void * const param);
+static int cmd_verify_data(unsigned int len, void * const param);
+
+static const func_cmd gs_command_function[CMD_MAX] = {
+	cmd_reset_init,
+	cmd_inject_key,
+	cmd_re_enc_data,
+	cmd_verify_key,
+	cmd_verify_data,
+};
+
+static uint8_t gs_work_addr_sram[WORK_ADR_SRAM_SIZE];
+
+/******************************************************************************
+ * Function Name : sec_module
+ * Description   : main function of sec_module
+ * Arguments     : none
+ * Return Value  : SEC_MODULE_RET_OK
+ *                  - success
+ *                 SEC_MODULE_RET_NG
+ *                  - fail
+ ******************************************************************************/
+int sec_module (void)
+{
+	e_cmd_type_t cmd = (e_cmd_type_t)gs_arguments.cmd;
+	unsigned int len = (unsigned int)gs_arguments.len;
+	void * prm = (void *)&gs_arguments.prm;
+    
+	if ((0 > cmd) || (CMD_MAX <= cmd)) {
+		return SEC_MODULE_RET_NG;
+	}
+    
+	return gs_command_function[cmd] (len, prm);
+} /* End of function sec_module() */
+
+/******************************************************************************
+ * Function Name : cmd_reset_init
+ * Description   : function of CMD_RESET_INIT command
+ * Arguments     : len
+ *                  - Size of command parameter
+ *                 param
+ *                  - Pointer where the command parameter is located
+ * Return Value  : SEC_MODULE_RET_OK
+ *                  - success
+ *                 SEC_MODULE_RET_NG
+ *                  - fail
+ ******************************************************************************/
+static int cmd_reset_init(unsigned int len, void* const param)
+{
+	unsigned long err;
+	unsigned char * S_RAMData;
+	unsigned char * S_INSTData;
+
+	st_reset_init_t* const p_reset_init = (st_reset_init_t *)param;
+
+	if((sizeof(st_reset_init_t) != len) || (NULL == p_reset_init)) {
+		return SEC_MODULE_RET_NG;
+	}
+
+	S_RAMData = (unsigned char *)gs_work_addr_sram;
+	S_INSTData = (unsigned char *)p_reset_init->inst_area;
+
+	err = R_TSIP_Init (S_RAMData, S_INSTData);
+	if (R_PASS != err) {
+		return SEC_MODULE_RET_NG;
+	}
+
+	return SEC_MODULE_RET_OK;
+} /* End of function cmd_reset_init() */
+
+/******************************************************************************
+ * Function Name : cmd_inject_key
+ * Description   : function of CMD_INJECT_KEY command
+ * Arguments     : len
+ *                  - Size of command parameter
+ *                 param
+ *                  - Pointer where the command parameter is located
+ * Return Value  : SEC_MODULE_RET_OK
+ *                  - success
+ *                 SEC_MODULE_RET_NG
+ *                  - fail
+ ******************************************************************************/
+static int cmd_inject_key(unsigned int len, void* const param)
+{
+
+	unsigned long err;
+	unsigned char *InData_ProvisioningKeyOperationCode;
+	unsigned char *InData_KeyRingOperationCode;
+
+	st_inject_key_t* const p_inject_key = (st_inject_key_t *)param;
+
+	if((sizeof(st_inject_key_t) != len) || (NULL == p_inject_key)) {
+		return SEC_MODULE_RET_NG;
+	}
+
+	InData_ProvisioningKeyOperationCode = (unsigned char *)p_inject_key->prov_key;
+	InData_KeyRingOperationCode = (unsigned char *)p_inject_key->key_ring;
+
+	err = R_TSIP_Inject_Key(InData_ProvisioningKeyOperationCode, InData_KeyRingOperationCode);
+	if (R_PASS != err) {
+		return SEC_MODULE_RET_NG;
+	}
+
+	return SEC_MODULE_RET_OK;
+} /* End of function cmd_inject_key() */
+
+/******************************************************************************
+ * Function Name : cmd_re_enc_data
+ * Description   : function of CMD_RE_ENC_DATA command
+ * Arguments     : len
+ *                  - Size of command parameter
+ *                 param
+ *                  - Pointer where the command parameter is located
+ * Return Value  : SEC_MODULE_RET_OK
+ *                  - success
+ *                 SEC_MODULE_RET_NG
+ *                  - fail
+ ******************************************************************************/
+static int cmd_re_enc_data(unsigned int len, void* const param)
+{
+	unsigned long err;
+	TSIP_REENC_BOOT_DATA tsip_reenc_boot_data;
+	st_re_enc_data_t* const p_re_enc_data = (st_re_enc_data_t *)param;
+
+	if((sizeof(st_re_enc_data_t) != len) || (NULL == p_re_enc_data)) {
+		return SEC_MODULE_RET_NG;
+	}
+
+	for (int i = 0; i < 16; i++) {
+		tsip_reenc_boot_data[i].InData_BootData = 0;
+		tsip_reenc_boot_data[i].InData_BootData_ByteSize = 0;
+		tsip_reenc_boot_data[i].OutData_BootData = 0;
+
+		if(i < p_re_enc_data->num) {
+			tsip_reenc_boot_data[i].InData_BootData = (unsigned char *)p_re_enc_data->list[i].src;
+			tsip_reenc_boot_data[i].InData_BootData_ByteSize = p_re_enc_data->list[i].len;
+			tsip_reenc_boot_data[i].OutData_BootData = (unsigned char *)p_re_enc_data->list[i].dst;
+		}
+	}
+
+	err = R_TSIP_ReEncBootData(&tsip_reenc_boot_data);
+	if (R_PASS != err) {
+		return SEC_MODULE_RET_NG;
+	}
+
+	return SEC_MODULE_RET_OK;
+} /* End of function cmd_re_enc_data() */
+
+/******************************************************************************
+ * Function Name : cmd_verify_key
+ * Description   : function of CMD_VERIFY_KEY command
+ * Arguments     : len
+ *                  - Size of command parameter
+ *                 param
+ *                  - Pointer where the command parameter is located
+ * Return Value  : SEC_MODULE_RET_OK
+ *                  - success
+ *                 SEC_MODULE_RET_NG
+ *                  - fail
+ ******************************************************************************/
+static int cmd_verify_key(unsigned int len, void* const param)
+{
+	unsigned long err;
+	(void)len;
+	(void)param;
+
+	err = R_TSIP_KeyRing_Verify();
+	if (R_PASS != err) {
+		return SEC_MODULE_RET_NG;
+	}
+
+	return SEC_MODULE_RET_OK;
+} /* End of function cmd_verify_key() */
+
+/******************************************************************************
+ * Function Name : cmd_verify_data
+ * Description   : function of CMD_VERIFY_DATA command
+ * Arguments     : len
+ *                  - Size of command parameter
+ *                 param
+ *                  - Pointer where the command parameter is located
+ * Return Value  : SEC_MODULE_RET_OK
+ *                  - success
+ *                 SEC_MODULE_RET_NG
+ *                  - fail
+ ******************************************************************************/
+static int cmd_verify_data(unsigned int len, void* const param)
+{
+	unsigned long err;
+	unsigned char *InData_BootData;
+	unsigned long InData_BootData_ByteSize;
+	unsigned char *InData_BootData_HeapArea;
+	unsigned char *OutData_BootData;
+
+	st_verify_data_t* const p_verify_data = (st_verify_data_t *)param;
+
+	if(sizeof(st_verify_data_t) != len) {
+		return SEC_MODULE_RET_NG;
+	}
+
+	InData_BootData = (unsigned char *)p_verify_data->src;
+	InData_BootData_ByteSize = p_verify_data->len;
+	InData_BootData_HeapArea = (unsigned char *)p_verify_data->heap;
+	OutData_BootData = (unsigned char *)p_verify_data->dst;
+
+	/* User Data decryption and verificaiton. In this sample, use same heap area for each user data */
+	err = R_TSIP_VerifyBootData (InData_BootData,
+	InData_BootData_ByteSize,
+	InData_BootData_HeapArea,
+	OutData_BootData);
+	if (R_PASS != err) {
+		return SEC_MODULE_RET_NG;
+	}
+
+	return SEC_MODULE_RET_OK;
+} /* End of function cmd_verify_data() */
+
diff --git a/plat/renesas/rzg/sec_module/sec_module.h b/plat/renesas/rzg/sec_module/sec_module.h
new file mode 100644
index 0000000..fcae317
--- /dev/null
+++ b/plat/renesas/rzg/sec_module/sec_module.h
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2020, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef SEC_MODULE_H
+#define SEC_MODULE_H
+
+/******************************************************************************
+Macro definitions
+******************************************************************************/
+
+/* Return Value */
+#define SEC_MODULE_RET_OK (0)
+#define SEC_MODULE_RET_NG (-1)
+
+#define SEC_MODULE_SHARED_SIZE (0x200)
+
+#define SEC_MODULE_ENTRY (SEC_MODULE_BASE + SEC_MODULE_SHARED_SIZE)
+
+#ifndef __ASSEMBLER__
+
+/******************************************************************************
+Typedef definitions
+******************************************************************************/
+
+typedef int (* fp_sec_module_api_t) (void);
+
+typedef enum {
+	CMD_RESET_INIT = 0,
+	CMD_INJECT_KEY,
+	CMD_RE_ENC_DATA,
+	CMD_VERIFY_KEY,
+	CMD_VERIFY_DATA,
+	CMD_MAX,
+} e_cmd_type_t;
+
+typedef struct {
+	uint64_t inst_area;
+} st_reset_init_t;
+
+typedef struct {
+	uint64_t key_ring;
+	uint64_t prov_key;
+} st_inject_key_t;
+
+typedef struct {
+	int num;
+	struct {
+		uint64_t src;
+		uint64_t len;
+		uint64_t dst;
+	} list[16];
+} st_re_enc_data_t;
+
+typedef struct {
+	uint64_t src;
+	uint64_t len;
+	uint64_t dst;
+	uint64_t heap;
+} st_verify_data_t;
+
+typedef struct {
+	uint64_t cmd;
+	uint64_t len;
+	union {
+		st_reset_init_t reset_init;
+		st_inject_key_t inject_key;
+		st_re_enc_data_t re_enc_data;
+		st_verify_data_t verify_data;
+	} prm;
+} st_sec_module_arg_t;
+
+/******************************************************************************
+Exported global functions (to be accessed by other files)
+******************************************************************************/
+
+#endif /* __ASSEMBLER__ */
+
+#endif /* SEC_MODULE_H */
diff --git a/plat/renesas/rzg/sec_module/sec_module.ld.S b/plat/renesas/rzg/sec_module/sec_module.ld.S
new file mode 100644
index 0000000..c976b4e
--- /dev/null
+++ b/plat/renesas/rzg/sec_module/sec_module.ld.S
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2019, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <platform_def.h>
+#include <lib/xlat_tables/xlat_tables_defs.h>
+#include <sec_module.h>
+
+OUTPUT_FORMAT(PLATFORM_LINKER_FORMAT)
+OUTPUT_ARCH(PLATFORM_LINKER_ARCH)
+ENTRY(sec_module)
+
+MEMORY {
+    RAM (rwx): ORIGIN = SEC_MODULE_BASE, LENGTH = SEC_MODULE_LIMIT - SEC_MODULE_BASE
+}
+
+
+SECTIONS
+{
+    . = SEC_MODULE_BASE;
+    ASSERT(. == ALIGN(PAGE_SIZE),
+           "SECMOD_BASE address is not aligned on a page boundary.")
+    arg . : {
+        KEEP(* (SHARED_AREA))
+       . = SEC_MODULE_SHARED_SIZE;
+    } >RAM
+    . = SEC_MODULE_ENTRY;
+    ro . : {
+        *(.text.sec_module)
+        *(.text*)
+        *(.rodata*)
+        . = ALIGN(PAGE_SIZE);
+        __RO_END__ = .;
+    } >RAM
+    __RW_START__ = . ;
+    .data . : {
+        __DATA_START__ = .;
+        *(.data*)
+        __DATA_END__ = .;
+    } >RAM
+    .bss : ALIGN(16) {
+        __BSS_START__ = .;
+        *(.bss*)
+        *(COMMON)
+        __BSS_END__ = .;
+    } >RAM
+    __RW_END__ = .;
+    __SECMOD_END__ = .;
+    __BSS_SIZE__ = SIZEOF(.bss);
+    ASSERT(. <= SEC_MODULE_LIMIT, "Security Module has exceeded its limit.")
+}
diff --git a/plat/renesas/rzg/sec_module/sec_module.mk b/plat/renesas/rzg/sec_module/sec_module.mk
new file mode 100644
index 0000000..24ab603
--- /dev/null
+++ b/plat/renesas/rzg/sec_module/sec_module.mk
@@ -0,0 +1,80 @@
+#
+# Copyright (c) 2020, Renesas Electronics Corporation. All rights reserved.
+#
+# SPDX-License-Identifier: BSD-3-Clause
+#
+
+SEC_MODULE_NAME	= sec_module
+
+# directory definition
+SEC_MODULE_TOP		= plat/renesas/rzg/${SEC_MODULE_NAME}
+SEC_MODULE_BUILD	= ${BUILD_PLAT}/${SEC_MODULE_NAME}
+
+
+#output file name
+SEC_MODULE_OUTPUT	= ${BUILD_PLAT}/${SEC_MODULE_NAME}.bin
+SEC_MODULE_SREC		= ${BUILD_PLAT}/${SEC_MODULE_NAME}.srec
+SEC_MODULE_ELF		= ${SEC_MODULE_BUILD}/${SEC_MODULE_NAME}.elf
+SEC_MODULE_MAPFILE	= ${SEC_MODULE_BUILD}/${SEC_MODULE_NAME}.map
+
+
+#input file name
+$(eval SEC_MODULE_SOURCES = ${SEC_MODULE_TOP}/sec_module.c)
+
+SEC_MODULE_LIBDIR	?= ${SEC_MODULE_TOP}
+
+SEC_MODULE_LIBRARY	= -L${SEC_MODULE_LIBDIR}
+
+ifeq (${LSI},G2H)
+	SEC_MODULE_LIBRARY	+= -lr_tsip_boot_lib_noos_g2h
+endif
+ifeq (${LSI},G2M)
+	SEC_MODULE_LIBRARY	+= -lr_tsip_boot_lib_noos_g2m
+endif
+ifeq (${LSI},G2N)
+	SEC_MODULE_LIBRARY	+= -lr_tsip_boot_lib_noos_g2n
+endif
+ifeq (${LSI},G2E)
+	SEC_MODULE_LIBRARY	+= -lr_tsip_boot_lib_noos_g2e
+endif
+
+PLAT_INCLUDES		+= -I${SEC_MODULE_TOP}
+
+#object file name
+$(eval BL2_OBJECTS = $(addprefix ${BUILD_PLAT}/bl2/,$(call SOURCES_TO_OBJS,${BL2_SOURCES} ${BL_COMMON_SOURCES})))
+$(eval SEC_MODULE_OBJECTS = $(addprefix ${SEC_MODULE_BUILD}/,$(call SOURCES_TO_OBJS,${SEC_MODULE_SOURCES})))
+
+
+#linker file name
+SEC_MODULE_LINKERFILE = ${SEC_MODULE_TOP}/sec_module.ld.S
+SEC_MODULE_SCRIPTFILE = ${SEC_MODULE_BUILD}/sec_module.ld
+SEC_MODULE_DEPENDENT  = $(SEC_MODULE_SCRIPTFILE:.ld=.d)
+
+# linker flags
+$(eval SEC_MODULE_LDFLAGS = --script ${SEC_MODULE_SCRIPTFILE} -Map ${SEC_MODULE_MAPFILE} ${SEC_MODULE_LIBRARY})
+
+###################################################
+# Compile
+
+$(SEC_MODULE_NAME): $(SEC_MODULE_OUTPUT)
+
+$(SEC_MODULE_OUTPUT) : $(SEC_MODULE_SREC)
+	$(Q)$(OC) -I srec -O binary --srec-forceS3 $(SEC_MODULE_SREC) $@
+
+
+$(SEC_MODULE_SREC): $(SEC_MODULE_ELF)
+	$(Q)$(ECHO) "generating srec: $@"
+	$(Q)$(OC) -O srec --srec-forceS3 $< $@
+
+
+$(SEC_MODULE_ELF):  $(SEC_MODULE_BUILD) $(SEC_MODULE_OBJECTS) libraries $(SEC_MODULE_SCRIPTFILE)
+	$(ECHO) "  LD      $@"
+	$(Q)$(LD) -o $@ $(TF_LDFLAGS) $(SEC_MODULE_OBJECTS) $(BL2_OBJECTS) $(LDPATHS) $(LDLIBS) $(SEC_MODULE_LDFLAGS)
+
+
+$(SEC_MODULE_SCRIPTFILE): $(SEC_MODULE_LINKERFILE)
+	$(ECHO) "  CPP     $@"
+	$(Q)$(CPP) $(CPPFLAGS) $(TF_CFLAGS_$(ARCH)) -P -x assembler-with-cpp -D__LINKER__ -Wp,-MD,$(SEC_MODULE_DEPENDENT) -MT $@ -MP -o $@ $<
+
+$(eval $(call MAKE_PREREQ_DIR,${SEC_MODULE_BUILD},${BUILD_PLAT}))
+$(eval $(call MAKE_OBJS,$(SEC_MODULE_BUILD),$(SEC_MODULE_SOURCES),2))
diff --git a/tools/renesas/rzg_layout_create/makefile b/tools/renesas/rzg_layout_create/makefile
index 13d24ff..4b0f5e2 100644
--- a/tools/renesas/rzg_layout_create/makefile
+++ b/tools/renesas/rzg_layout_create/makefile
@@ -55,6 +55,12 @@ endif
 endif
 $(eval $(call add_define,RCAR_SA6_TYPE))
 
+# Process SPD_NONE flag
+ifeq (${SPD_NONE},1)
+SPD_NONE := 1
+$(eval $(call add_define,SPD_NONE))
+endif
+
 RCAR_VMA_ADJUST_ADDR := 0xE6320000
 $(eval $(call add_define,RCAR_VMA_ADJUST_ADDR))
 
diff --git a/tools/renesas/rzg_layout_create/sa6.c b/tools/renesas/rzg_layout_create/sa6.c
index d14c899..7c2a41d 100644
--- a/tools/renesas/rzg_layout_create/sa6.c
+++ b/tools/renesas/rzg_layout_create/sa6.c
@@ -13,6 +13,14 @@
 
 /* Number of content cert for Non-secure Target Program(BL33x) */
 #define RCAR_IMAGE_NUM			(0x00000001U)
+/* Source address on Security Module */
+#define SEC_MODSRC_ADDRESS	(0x00400000U)
+/* Reserved */
+#define SEC_MOD_PARTITION	(0x00000000U)
+/* Source address on Trusted Keyring */
+#define SEC_KEYSRC_ADDRESS	(0x00500000U)
+/* Reserved */
+#define SEC_KEY_PARTITION	(0x00000000U)
 /* Source address on flash for BL31 */
 #define RCAR_BL31SRC_ADDRESS		(0x001C0000U)
 /* Reserved */
@@ -87,6 +95,29 @@
 
 #endif /* RCAR_SA6_TYPE == RCAR_SA6_TYPE_HYPERFLASH */
 
+/* Destination address for Security Module */
+#ifndef SPD_NONE
+#define SEC_MODDST_ADDRESS		(0x440E0000U)
+#define SEC_MODDST_ADDRESSH		(0x00000000U)
+/* Destination size for Security Module */
+#define SEC_MODDST_SIZE			(0x00007800U)
+/* Destination address for Secure Keys */
+#define SEC_KEYDST_ADDRESS		(0x440FE000U)
+#define SEC_KEYDST_ADDRESSH		(0x00000000U)
+/* Destination size for Secure Keys */
+#define SEC_KEYDST_SIZE			(0x00000400U)
+#else
+#define SEC_MODDST_ADDRESS		(0x4A000000U)
+#define SEC_MODDST_ADDRESSH		(0x00000000U)
+/* Destination size for Security Module */
+#define SEC_MODDST_SIZE			(0x00007800U)
+/* Destination address for Secure Keys */
+#define SEC_KEYDST_ADDRESS		(0x4A01E000U)
+#define SEC_KEYDST_ADDRESSH		(0x00000000U)
+/* Destination size for Secure Keys */
+#define SEC_KEYDST_SIZE			(0x00000400U)
+#endif
+
 /* Destination address for BL31 */
 #define RCAR_BL31DST_ADDRESS		(0x44000000U)
 #define RCAR_BL31DST_ADDRESSH		(0x00000000U)
@@ -133,6 +164,10 @@
 
 /* SA6 */
 const uint64_t __attribute__ ((section (".sa6_image_num")))	image_num	= RCAR_IMAGE_NUM;
+const uint64_t __attribute__ ((section (".sa6_secmodsrc_addr"))) secmodsrc_addr	= SEC_MODSRC_ADDRESS;
+const uint64_t __attribute__ ((section (".sa6_secmodpartition")))secmodpartition= SEC_MOD_PARTITION;
+const uint64_t __attribute__ ((section (".sa6_seckeysrc_addr"))) seckeysrc_addr	= SEC_KEYSRC_ADDRESS;
+const uint64_t __attribute__ ((section (".sa6_seckeypartition")))seckeypartition= SEC_KEY_PARTITION;
 const uint64_t __attribute__ ((section (".sa6_bl31src_addr")))	bl31src_addr	= RCAR_BL31SRC_ADDRESS;
 const uint64_t __attribute__ ((section (".sa6_bl31partition")))	bl31partition	= RCAR_BL31_PARTITION;
 const uint64_t __attribute__ ((section (".sa6_bl32src_addr")))	bl32src_addr	= RCAR_BL32SRC_ADDRESS;
@@ -153,6 +188,12 @@ const uint64_t __attribute__ ((section (".sa6_bl337src_addr")))	bl337src_addr	=
 const uint64_t __attribute__ ((section (".sa6_bl337partition")))bl337partition	= RCAR_BL337_PARTITION;
 const uint64_t __attribute__ ((section (".sa6_bl338src_addr")))	bl338src_addr	= RCAR_BL338SRC_ADDRESS;
 const uint64_t __attribute__ ((section (".sa6_bl338partition")))bl338partition	= RCAR_BL338_PARTITION;
+const uint32_t __attribute__ ((section (".sa6_secmoddst_addr"))) secmoddst_addr	= SEC_MODDST_ADDRESS;
+const uint32_t __attribute__ ((section (".sa6_secmoddst_addrh")))secmoddst_addrh= SEC_MODDST_ADDRESSH;
+const uint32_t __attribute__ ((section (".sa6_secmoddst_size"))) secmoddst_size	= SEC_MODDST_SIZE;
+const uint32_t __attribute__ ((section (".sa6_seckeydst_addr"))) seckeydst_addr	= SEC_KEYDST_ADDRESS;
+const uint32_t __attribute__ ((section (".sa6_seckeydst_addrh")))seckeydst_addrh= SEC_KEYDST_ADDRESSH;
+const uint32_t __attribute__ ((section (".sa6_seckeydst_size"))) seckeydst_size	= SEC_KEYDST_SIZE;
 const uint32_t __attribute__ ((section (".sa6_bl31dst_addr")))	bl31dst_addr	= RCAR_BL31DST_ADDRESS;
 const uint32_t __attribute__ ((section (".sa6_bl31dst_addrh")))	bl31dst_addrh	= RCAR_BL31DST_ADDRESSH;
 const uint32_t __attribute__ ((section (".sa6_bl31dst_size")))	bl31dst_size	= RCAR_BL31DST_SIZE;
diff --git a/tools/renesas/rzg_layout_create/sa6.ld.S b/tools/renesas/rzg_layout_create/sa6.ld.S
index 701d8ec..6f1f185 100644
--- a/tools/renesas/rzg_layout_create/sa6.ld.S
+++ b/tools/renesas/rzg_layout_create/sa6.ld.S
@@ -12,6 +12,17 @@ SECTIONS
 		. = 0x00000008;
 	}
 
+	.src_addr_sec : {
+		KEEP(*(.sa6_secmodsrc_addr))
+		. = 0x00000008;
+		KEEP(*(.sa6_secmodpartition))
+		. = 0x000000010;
+		KEEP(*(.sa6_seckeysrc_addr))
+		. = 0x000000018;
+		KEEP(*(.sa6_seckeypartition))
+		. = 0x00000020;
+	}
+
 	.src_addr : {
 		KEEP(*(.sa6_bl31src_addr))
 		. = 0x00000008;
@@ -56,6 +67,21 @@ SECTIONS
 
 	. = 0x00000554;
 
+	.dst_addr_sec : {
+		KEEP(*(.sa6_secmoddst_addr))
+		. = 0x00000004;
+		KEEP(*(.sa6_secmoddst_addrh))
+		. = 0x00000110;
+		KEEP(*(.sa6_secmoddst_size))
+		. = 0x00000800;
+		KEEP(*(.sa6_seckeydst_addr))
+		. = 0x00000804;
+		KEEP(*(.sa6_seckeydst_addrh))
+		. = 0x00000910;
+		KEEP(*(.sa6_seckeydst_size))
+		. = 0x00001000;
+	}
+
 	.dst_addr : {
 		KEEP(*(.sa6_bl31dst_addr))
 		. = 0x00000004;
-- 
2.7.4

