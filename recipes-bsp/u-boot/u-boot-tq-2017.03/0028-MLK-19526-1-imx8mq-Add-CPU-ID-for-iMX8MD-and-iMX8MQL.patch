From d4de2f100f72b9e213b426ba6b36fa42a7e6c852 Mon Sep 17 00:00:00 2001
From: Ye Li <ye.li@nxp.com>
Date: Mon, 10 Sep 2018 20:22:52 -0700
Subject: [PATCH] MLK-19526-1 imx8mq: Add CPU ID for iMX8MD and iMX8MQLite

iMX8MQ has two variant versions: iMX8MD and iMX8MQLite. Add dummy CPU ID
for these two, and check the fuses to get correct versions.

MLK-19526-2 imx8mq: Update kernel DTB for iMX8MD and iMX8MQLite

Since VPU/DCSS/HDMI are disabled on iMX8QLite, the CPU core 2/3 are disabled
on iMX8MD, we have to update kernel DTB to disable relevant nodes. The MIPI-DSI
can input from DCSS or LCDIF, so we need to check the input in DTB and only

backport squash & resolve conflicts


Signed-off-by: Ye Li <ye.li@nxp.com>
(cherry picked from commit 79e8d0441d8c5cf8bde5ce1e332ffcb780c86986)
Signed-off-by: Markus Niebel <Markus.Niebel@tq-group.com>

Signed-off-by: Ye Li <ye.li@nxp.com>
(cherry picked from commit 58b77b541311d4b1d7db787cc769a7ad23ecbc79)
Signed-off-by: Markus Niebel <Markus.Niebel@tq-group.com>
---
 arch/arm/cpu/armv8/imx8m/soc.c              | 254 ++++++++++++++++----
 arch/arm/imx-common/cpu.c                   |   6 +-
 arch/arm/include/asm/arch-imx/cpu.h         |   3 +
 arch/arm/include/asm/imx-common/sys_proto.h |   3 +
 4 files changed, 212 insertions(+), 54 deletions(-)

diff --git a/arch/arm/cpu/armv8/imx8m/soc.c b/arch/arm/cpu/armv8/imx8m/soc.c
index 80531f1e6b..fe44c67744 100644
--- a/arch/arm/cpu/armv8/imx8m/soc.c
+++ b/arch/arm/cpu/armv8/imx8m/soc.c
@@ -14,6 +14,7 @@
 #include <asm/armv8/mmu.h>
 #include <errno.h>
 #include <fdt_support.h>
+#include <fdtdec.h>
 #include <fsl_wdog.h>
 #include <generated/version_autogenerated.h>
 
@@ -211,27 +212,62 @@ static struct mm_region imx8m_mem_map[] = {
 };
 struct mm_region *mem_map = imx8m_mem_map;
 
+static u32 get_cpu_variant_type(u32 type)
+{
+	if (type == MXC_CPU_IMX8MQ) {
+		struct ocotp_regs *ocotp = (struct ocotp_regs *)OCOTP_BASE_ADDR;
+		struct fuse_bank *bank = &ocotp->bank[1];
+		struct fuse_bank1_regs *fuse =
+			(struct fuse_bank1_regs *)bank->fuse_regs;
+
+		u32 value = readl(&fuse->tester4);
+
+		if ((value & 0x3) == 0x2)
+			return MXC_CPU_IMX8MD;
+		else if (value & 0x200000)
+			return MXC_CPU_IMX8MQL;
+	}
+
+	return type;
+}
+
 u32 get_cpu_rev(void)
 {
 	u32 reg = readl((void __iomem *)DIGPROG);
 	u32 type = (reg >> 16) & 0xff;
+	u32 major_low = (reg >> 8) & 0xff;
+	u32 rom_version;
 
 	reg &= 0xff;
 
-	if (reg == 0x10) {
-		/* For B0 chip, the DIGPROG is not updated, still TO1.0.
-		 * we have to check ROM version further
-		 */
-		uint32_t rom_version;
-		rom_version = readl((void __iomem *)0x800);
-		if (rom_version != 0x10) {
-			rom_version = readl((void __iomem *)0x83c);
-			if (rom_version >= 0x20)
-				reg = 0x20;
+	/* iMX8MM */
+	 if (major_low == 0x41) {
+		return (MXC_CPU_IMX8MM << 12) | reg;
+	} else {
+		/* iMX8MQ */
+		if (reg == CHIP_REV_1_0) {
+			/*
+			 * For B0 chip, the DIGPROG is not updated, still TO1.0.
+			 * we have to check ROM version or OCOTP_READ_FUSE_DATA
+			 */
+			if (readl((void __iomem *)(OCOTP_BASE_ADDR + 0x40))
+				== 0xff0055aa) {
+				/* 0xff0055aa is magic number for B1 */
+				reg = CHIP_REV_2_1;
+			} else {
+				rom_version = readb((void __iomem *)ROM_VERSION_A0);
+				if (rom_version != CHIP_REV_1_0) {
+					rom_version = readb((void __iomem *)ROM_VERSION_B0);
+					if (rom_version == CHIP_REV_2_0)
+						reg = CHIP_REV_2_0;
+				}
+			}
 		}
-	}
 
-	return (type << 12) | reg;
+		type = get_cpu_variant_type(type);
+
+		return (type << 12) | reg;
+	}
 }
 
 void imx_set_wdog_powerdown(bool enable)
@@ -438,45 +474,151 @@ static int ft_add_optee_node(void *fdt, bd_t *bd)
 	return 0;
 }
 
-int ft_system_setup(void *blob, bd_t *bd)
+static int disable_fdt_nodes(void *blob, const char *nodes_path[], int size_array)
 {
-	if (get_boot_device() == USB_BOOT) {
-		const char *nodes_path[] = {
-			"/dcss@32e00000",
-			"/hdmi@32c00000",
-			"/hdmi_cec@32c33800",
-			"/hdmi_drm@32c00000",
-			"/display-subsystem",
-			"/sound-hdmi"
-		};
-
-		int i = 0;
-		int rc;
-		int nodeoff;
-		const char *status = "disabled";
+	int i = 0;
+	int rc;
+	int nodeoff;
+	const char *status = "disabled";
 
-		for (i = 0; i < ARRAY_SIZE(nodes_path); i++) {
-			nodeoff = fdt_path_offset(blob, nodes_path[i]);
-			if (nodeoff < 0)
-				continue; /* Not found, skip it */
+	for (i = 0; i < size_array; i++) {
+		nodeoff = fdt_path_offset(blob, nodes_path[i]);
+		if (nodeoff < 0)
+			continue; /* Not found, skip it */
 
-			printf("Found %s node\n", nodes_path[i]);
+		printf("Found %s node\n", nodes_path[i]);
 
 add_status:
-			rc = fdt_setprop(blob, nodeoff, "status", status, strlen(status) + 1);
-			if (rc) {
-				if (rc == -FDT_ERR_NOSPACE) {
-					rc = fdt_increase_size(blob, 512);
-					if (!rc)
-						goto add_status;
-				}
-				printf("Unable to update property %s:%s, err=%s\n",
-					nodes_path[i], "status", fdt_strerror(rc));
-			} else {
-				printf("Modify %s:%s disabled\n",
-					nodes_path[i], "status");
+		rc = fdt_setprop(blob, nodeoff, "status", status, strlen(status) + 1);
+		if (rc) {
+			if (rc == -FDT_ERR_NOSPACE) {
+				rc = fdt_increase_size(blob, 512);
+				if (!rc)
+					goto add_status;
 			}
+			printf("Unable to update property %s:%s, err=%s\n",
+				nodes_path[i], "status", fdt_strerror(rc));
+		} else {
+			printf("Modify %s:%s disabled\n",
+				nodes_path[i], "status");
 		}
+	}
+
+	return 0;
+}
+
+static int disable_mipi_dsi_nodes(void *blob)
+{
+	const char *nodes_path[] = {
+		"/mipi_dsi@30A00000",
+		"/mipi_dsi_bridge@30A00000",
+		"/dsi_phy@30A00300"
+	};
+
+	return disable_fdt_nodes(blob, nodes_path, ARRAY_SIZE(nodes_path));
+}
+
+static int disable_dcss_nodes(void *blob)
+{
+	const char *nodes_path[] = {
+		"/dcss@0x32e00000",
+		"/dcss@32e00000",
+		"/hdmi@32c00000",
+		"/hdmi_cec@32c33800",
+		"/hdmi_drm@32c00000",
+		"/display-subsystem",
+		"/sound-hdmi"
+	};
+
+	return disable_fdt_nodes(blob, nodes_path, ARRAY_SIZE(nodes_path));
+}
+
+static int disable_vpu_nodes(void *blob)
+{
+	const char *nodes_path[] = {
+		"/vpu@38300000"
+	};
+
+	return disable_fdt_nodes(blob, nodes_path, ARRAY_SIZE(nodes_path));
+}
+
+static int disable_cpu_nodes(void *blob)
+{
+	const char *nodes_path[] = {
+			"/cpus/cpu@2",
+			"/cpus/cpu@3",
+	};
+
+	int i = 0;
+	int rc;
+	int nodeoff;
+
+	for (i = 0; i < ARRAY_SIZE(nodes_path); i++) {
+		nodeoff = fdt_path_offset(blob, nodes_path[i]);
+		if (nodeoff < 0)
+			continue; /* Not found, skip it */
+
+		printf("Found %s node\n", nodes_path[i]);
+
+		rc = fdt_del_node(blob, nodeoff);
+		if (rc < 0) {
+			printf("Unable to delete node %s, err=%s\n",
+				nodes_path[i], fdt_strerror(rc));
+		} else {
+			printf("Delete node %s\n", nodes_path[i]);
+		}
+	}
+
+	return 0;
+}
+
+static int check_mipi_dsi_nodes(void *blob)
+{
+	const char *lcdif_path = "/lcdif@30320000";
+	const char *mipi_dsi_path = "/mipi_dsi@30A00000";
+
+	const char *lcdif_ep_path = "/lcdif@30320000/port@0/mipi-dsi-endpoint";
+	const char *mipi_dsi_ep_path = "/mipi_dsi@30A00000/port@1/endpoint";
+
+	int nodeoff;
+	nodeoff = fdt_path_offset(blob, lcdif_path);
+	if (nodeoff < 0 || !fdtdec_get_is_enabled(blob, nodeoff)) {
+		/* If can't find lcdif node or lcdif node is disabled, then disable all mipi dsi,
+		    since they only can input from DCSS */
+		return disable_mipi_dsi_nodes(blob);
+	}
+
+	nodeoff = fdt_path_offset(blob, mipi_dsi_path);
+	if (nodeoff < 0 || !fdtdec_get_is_enabled(blob, nodeoff))
+		return 0;
+
+	nodeoff = fdt_path_offset(blob, lcdif_ep_path);
+	if (nodeoff < 0) {
+		/* If can't find lcdif endpoint, then disable all mipi dsi,
+		    since they only can input from DCSS */
+		return disable_mipi_dsi_nodes(blob);
+	} else {
+		int lookup_node;
+		lookup_node = fdtdec_lookup_phandle(blob, nodeoff, "remote-endpoint");
+		nodeoff = fdt_path_offset(blob, mipi_dsi_ep_path);
+
+		if (nodeoff >0 && nodeoff == lookup_node)
+			return 0;
+
+		return disable_mipi_dsi_nodes(blob);
+	}
+
+}
+
+int ft_system_setup(void *blob, bd_t *bd)
+{
+	int i = 0;
+	int rc;
+	int nodeoff;
+
+	if (get_boot_device() == USB_BOOT) {
+
+		disable_dcss_nodes(blob);
 
 		const char *usb_dwc3_path = "/usb@38100000/dwc3";
 		nodeoff = fdt_path_offset(blob, usb_dwc3_path);
@@ -506,17 +648,13 @@ usb_modify_speed:
 
 	/* Disable the CPU idle for A0 chip since the HW does not support it */
 	if (is_soc_rev(CHIP_REV_1_0)) {
-		const char *nodes_path[] = {
+		static const char * const nodes_path[] = {
 			"/cpus/cpu@0",
 			"/cpus/cpu@1",
 			"/cpus/cpu@2",
 			"/cpus/cpu@3",
 		};
 
-		int i = 0;
-		int rc;
-		int nodeoff;
-
 		for (i = 0; i < ARRAY_SIZE(nodes_path); i++) {
 			nodeoff = fdt_path_offset(blob, nodes_path[i]);
 			if (nodeoff < 0)
@@ -527,14 +665,24 @@ usb_modify_speed:
 			rc = fdt_delprop(blob, nodeoff, "cpu-idle-states");
 			if (rc) {
 				printf("Unable to update property %s:%s, err=%s\n",
-					nodes_path[i], "status", fdt_strerror(rc));
-			} else {
-				printf("Remove %s:%s\n",
-					nodes_path[i], "cpu-idle-states");
+				       nodes_path[i], "status", fdt_strerror(rc));
+				return rc;
 			}
+
+			printf("Remove %s:%s\n", nodes_path[i],
+			       "cpu-idle-states");
 		}
 	}
 
+	if (is_imx8mql()) {
+		disable_vpu_nodes(blob);
+		disable_dcss_nodes(blob);
+		check_mipi_dsi_nodes(blob);
+	}
+
+	if (is_imx8md())
+		disable_cpu_nodes(blob);
+
 	return ft_add_optee_node(blob, bd);
 }
 #endif
diff --git a/arch/arm/imx-common/cpu.c b/arch/arm/imx-common/cpu.c
index e798ee6a0a..0641356541 100644
--- a/arch/arm/imx-common/cpu.c
+++ b/arch/arm/imx-common/cpu.c
@@ -152,7 +152,11 @@ const char *get_imx_type(u32 imxtype)
 {
 	switch (imxtype) {
 	case MXC_CPU_IMX8MQ:
-		return "8MQ";	/* Quad-core version of the imx8m */
+		return "8MQ";	/* Quad-core version of the imx8mq */
+	case MXC_CPU_IMX8MQL:
+		return "8MQLite";	/* Quad-core Lite version of the imx8mq */
+	case MXC_CPU_IMX8MD:
+		return "8MD";	/* Dual-core version of the imx8mq */
 	case MXC_CPU_MX7S:
 		return "7S";	/* Single-core version of the mx7 */
 	case MXC_CPU_MX7D:
diff --git a/arch/arm/include/asm/arch-imx/cpu.h b/arch/arm/include/asm/arch-imx/cpu.h
index dd392a1233..2280d81573 100644
--- a/arch/arm/include/asm/arch-imx/cpu.h
+++ b/arch/arm/include/asm/arch-imx/cpu.h
@@ -27,6 +27,9 @@
 #define MXC_CPU_MX7D		0x72
 #define MXC_CPU_MX7ULP		0xE1 /* dummy ID */
 #define MXC_CPU_IMX8MQ		0x82
+#define MXC_CPU_IMX8MD		0x83 /* dummy ID */
+#define MXC_CPU_IMX8MQL		0x84 /* dummy ID */
+#define MXC_CPU_IMX8MM		0x85 /* dummy ID */
 #define MXC_CPU_IMX8QM		0x91 /* dummy ID */
 #define MXC_CPU_IMX8QXP		0x92 /* dummy ID */
 #define MXC_CPU_IMX8DX		0x93 /* dummy ID */
diff --git a/arch/arm/include/asm/imx-common/sys_proto.h b/arch/arm/include/asm/imx-common/sys_proto.h
index 431e297145..f37b9d47b6 100644
--- a/arch/arm/include/asm/imx-common/sys_proto.h
+++ b/arch/arm/include/asm/imx-common/sys_proto.h
@@ -44,6 +44,9 @@
 
 #define is_mx7ulp() (is_cpu_type(MXC_CPU_MX7ULP))
 
+#define is_imx8mq() (is_cpu_type(MXC_CPU_IMX8MQ) || is_cpu_type(MXC_CPU_IMX8MD) || is_cpu_type(MXC_CPU_IMX8MQL))
+#define is_imx8md() (is_cpu_type(MXC_CPU_IMX8MD))
+#define is_imx8mql() (is_cpu_type(MXC_CPU_IMX8MQL))
 #define is_imx8qm() (is_cpu_type(MXC_CPU_IMX8QM))
 #define is_imx8qxp() (is_cpu_type(MXC_CPU_IMX8QXP))
 #define is_imx8dx() (is_cpu_type(MXC_CPU_IMX8DX))
