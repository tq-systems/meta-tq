From 983f39ea2805da8f10f0693d52e6434364698378 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Alvin=20=C5=A0ipraga?= <alvin@airtame.com>
Date: Fri, 14 Dec 2018 13:55:52 +0100
Subject: [PATCH 055/188] rtc: pcf85063: preserve control register value
 between stop and start
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Fix a bug that caused the Control_1 register to get zeroed whenever the
RTC time is set. The problem occurred between stopping and starting the
RTC clock, wherein the return value of a successful I2C write function
would get written to the register.

Also update variables of the start and stop functions to be more
consistent with the rest of the driver.

Signed-off-by: Alvin Å ipraga <alvin@airtame.com>
Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
(imported from commit ec9cf1b7a6af2c0cffaa887351e7c7acced5290e)
---
 drivers/rtc/rtc-pcf85063.c | 21 +++++++++++----------
 1 file changed, 11 insertions(+), 10 deletions(-)

diff --git a/drivers/rtc/rtc-pcf85063.c b/drivers/rtc/rtc-pcf85063.c
index 06a95901f9d4..c2e4ac1b3c88 100644
--- a/drivers/rtc/rtc-pcf85063.c
+++ b/drivers/rtc/rtc-pcf85063.c
@@ -48,37 +48,38 @@ static struct i2c_driver pcf85063_driver;
 
 static int pcf85063_stop_clock(struct i2c_client *client, u8 *ctrl1)
 {
-	s32 ret;
+	int rc;
+	u8 reg;
 
-	ret = i2c_smbus_read_byte_data(client, PCF85063_REG_CTRL1);
-	if (ret < 0) {
+	rc = i2c_smbus_read_byte_data(client, PCF85063_REG_CTRL1);
+	if (rc < 0) {
 		dev_err(&client->dev, "Failing to stop the clock\n");
 		return -EIO;
 	}
 
 	/* stop the clock */
-	ret |= PCF85063_REG_CTRL1_STOP;
+	reg = rc | PCF85063_REG_CTRL1_STOP;
 
-	ret = i2c_smbus_write_byte_data(client, PCF85063_REG_CTRL1, ret);
-	if (ret < 0) {
+	rc = i2c_smbus_write_byte_data(client, PCF85063_REG_CTRL1, reg);
+	if (rc < 0) {
 		dev_err(&client->dev, "Failing to stop the clock\n");
 		return -EIO;
 	}
 
-	*ctrl1 = ret;
+	*ctrl1 = reg;
 
 	return 0;
 }
 
 static int pcf85063_start_clock(struct i2c_client *client, u8 ctrl1)
 {
-	s32 ret;
+	int rc;
 
 	/* start the clock */
 	ctrl1 &= ~PCF85063_REG_CTRL1_STOP;
 
-	ret = i2c_smbus_write_byte_data(client, PCF85063_REG_CTRL1, ctrl1);
-	if (ret < 0) {
+	rc = i2c_smbus_write_byte_data(client, PCF85063_REG_CTRL1, ctrl1);
+	if (rc < 0) {
 		dev_err(&client->dev, "Failing to start the clock\n");
 		return -EIO;
 	}
